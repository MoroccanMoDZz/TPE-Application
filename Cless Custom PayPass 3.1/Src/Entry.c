/** \file Entry.c
 *
 * Application entry point.
 * This file was automatically generated by IngeDev and must be filled out
 * by the developer.
 *                   
 * Purpose :
 *
 * Each time Manager calls an application, it generates only one service
 * call that reaches your application main with the corresponding service
 * number.
 *
 * List of routines in file :
 * - give_your_domain : Return application domain.
 * - after_reset : Application reset processing.
 * -  is_name : Report application name to Manager.
 * -  is_state : Return application status (initialise or not).
 * -  idle_message : Dedicated to display idle message.
 * -  more_function : Dedicated to navigation menus.
 * -  keyboard_event : Return key pressed.
 * -  state : Print terminal content.
 * -  consult : Print daily totals.
 * -  mcall : Print call schedule.
 * -  is_time_function : Need pheripherals at the next call time_function()
 * -  time_function : Allow automatic execution of periodic functions.
 * -  is_change_init : Conditions for changing manager parameters?
 * -  modif_param : Manager reports parameters changing.
 * -  is_evol_pg : Conditions for application downloading?
 * -  is_delete : Conditions for application deletion?
 * -  file_received : Manager reports parameters file received from LLT.
 * -  message_received : Inter application messaging.
 * -  is_card_specific : Card needs a specific process?
 * -  card_inside : Transaction in progress for a specific card.
 * -  is_for_you_before : Is chip card as an ISO 7816-3?
 * -  is_for_you_after : recognise mag, smc or man card in order to be a candidate.     
 * -  cless_give_info : contactless parameters for each contactless application.  
 * -  cless_debit_aid : contactless debit with AID allready selected.  
 * -  give_interface : Services registration and priority.
 * -  entry : Call by OS for recording services and opening DLL(s). 
 */


/////////////////////////////////////////////////////////////////
//// Includes ///////////////////////////////////////////////////

#include "ClessSample_Implementation.h"


/////////////////////////////////////////////////////////////////
//// Macros & preprocessor definitions //////////////////////////

#define SERVICES_LOW_PRIORITY			30
#define SERVICES_HIGH_PRIORITY			10
#define SERVICES_DEFAULT_PRIORITY		20


/////////////////////////////////////////////////////////////////
//// Static functions definition ////////////////////////////////

void entry(void);
static int select_function_emv_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out);
static int Main_(unsigned int nSize, StructPt* pData);
static int give_your_domain_ (NO_SEGMENT no, S_INITPARAMOUT *param_out);
static int give_money_extended_ (NO_SEGMENT no , void * p1, S_MONEYOUT_EXTENDED * moneyout);
static int after_reset_ (NO_SEGMENT no, S_TRANSOUT *param_out);
static int is_name_(NO_SEGMENT no, S_ETATOUT *param_out);
static int is_state_(NO_SEGMENT no, S_ETATOUT *param_out);
static int idle_message_ (NO_SEGMENT no);
static int more_function_ (NO_SEGMENT no);
static int keyboard_event_ (NO_SEGMENT noappli,S_KEY *key_in,S_KEY *key_out);
static int state_ (NO_SEGMENT no);
//static int consult_ (NO_SEGMENT no);
//static int mcall_ (NO_SEGMENT no);
static int is_time_function_ (NO_SEGMENT no, S_ETATOUT *param_out);
//static int time_function_ (NO_SEGMENT no);
static int is_change_init_(NO_SEGMENT no, S_ETATOUT *param_out);
//static int modif_param_(NO_SEGMENT noappli, S_MODIF_P *param_in);
static int is_evol_pg_ (NO_SEGMENT no, S_ETATOUT *param_out);
static int is_delete_ (NO_SEGMENT no, S_DELETE *param_out);
static int file_received_ (NO_SEGMENT no, S_FILE *param_in);
static int message_received_ (NO_SEGMENT no, S_MESSAGE_IAM *param_in);
static int is_card_specific_ (NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out);
//static int card_inside_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out);
//static int is_for_you_after_ (NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out);
//static int debit_non_emv_ (NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out);
static int give_your_specific_context_(const NO_SEGMENT AppliNum, S_SPECIFIC_CONTEXT* pParamOut);
//static int cless_give_info_ (NO_SEGMENT no, S_TRANSIN * param_in, S_CLESS_GIVEINFO * param_out);
//static int cless_debit_aid_ (NO_SEGMENT no, unsigned int nSize, void * pData);
//static int cless_end_ (NO_SEGMENT nAppliNum);
static int give_interface_ (unsigned short AppliNum, void* pParamIn, void* pParamOut);
static int custom_kernel_ (unsigned int nSize, void * pData);
static int de_kernel_ (unsigned int nSize, void * pData);
///static int custom_appli_selection_proc (unsigned int nSize, void * pData);
///static int custom_selection_gui (unsigned int nSize, void * pData);
///static void Customize_message(int size, InfosMSG_CUST *infoscust);
static void	Test_DLL_Security_Presence(void);

extern Telium_File_t *hKbd;      // Handle of the peripheral Keyboard

/////////////////////////////////////////////////////////////////

#ifdef __FRAMEWORK_TELIUM_2__
#undef Telium_service_desc_t
#define Telium_service_desc_t svc_service_desc_t
#undef Telium_callback
#define Telium_callback svc_callback
#endif

static Telium_service_desc_t ServicesStandard[] = {
	{ 0, AFTER_RESET, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },

#ifndef __TELIUM3__
	{ 0, IDLE_MESSAGE, (Telium_callback)Main_, 254},//Cless
#endif

	//{ 0, IS_CARD_EMV_FOR_YOU, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_CARD_SPECIFIC, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_CHANGE_INIT, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_DELETE, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_EVOL_PG, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_FOR_YOU_AFTER, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_FOR_YOU_BEFORE, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_LICENCED, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_NAME, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_STATE, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_TIME_FUNCTION, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_YOUR_DOMAIN, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_MONEY_EXTENDED, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
//	{ 0, MORE_FUNCTION, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, STATE, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
//	{ 0, CLESS_GIVE_INFO, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
//	{ 0, CLESS_DEBIT_AID, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
//	{ 0, CLESS_END, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, FILE_RECEIVED, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, SERVICE_CUSTOM_KERNEL, (Telium_callback)custom_kernel_, SERVICES_DEFAULT_PRIORITY },
	{ 0, SERVICE_DE_KERNEL, (Telium_callback)de_kernel_, SERVICES_DEFAULT_PRIORITY },
	///{ 0, CLESS_SERVICE_CUST_IMPSEL_AS_PROC, (SAP)custom_appli_selection_proc, SERVICES_DEFAULT_PRIORITY },
	///{ 0, CLESS_SERVICE_CUST_IMPSEL_GUI, (SAP)custom_selection_gui, SERVICES_DEFAULT_PRIORITY },
	{ 0, SELECT_FUNCTION_EMV, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_YOUR_SPECIFIC_CONTEXT, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
//#ifndef __TELIUM3__
	{ 0, KEYBOARD_EVENT, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, MESSAGE_RECEIVED, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
//#endif
};


#ifndef DISABLE_UNATTENDED
static Telium_service_desc_t ServicesUnattended[] = {
	{ 0, AFTER_RESET, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IDLE_MESSAGE, (Telium_callback)Main_, 254},//Cless_
	{ 0, IS_CARD_SPECIFIC, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_CHANGE_INIT, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_DELETE, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_NAME, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_STATE, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_YOUR_DOMAIN, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_MONEY_EXTENDED, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
//	{ 0, MORE_FUNCTION, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, STATE, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	///{ 0, CLESS_GIVE_INFO, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	///{ 0, CLESS_DEBIT_AID, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	///{ 0, CLESS_END, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, FILE_RECEIVED, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, SERVICE_CUSTOM_KERNEL, (Telium_callback)custom_kernel_, SERVICES_DEFAULT_PRIORITY },
	{ 0, SERVICE_DE_KERNEL, (Telium_callback)de_kernel_, SERVICES_DEFAULT_PRIORITY },
	///{ 0, CLESS_SERVICE_CUST_IMPSEL_AS_PROC, (SAP)custom_appli_selection_proc, SERVICES_DEFAULT_PRIORITY },
	///{ 0, CLESS_SERVICE_CUST_IMPSEL_GUI, (SAP)custom_selection_gui, SERVICES_DEFAULT_PRIORITY },
	{ 0, SELECT_FUNCTION_EMV, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_YOUR_SPECIFIC_CONTEXT, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, KEYBOARD_EVENT, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, COM_EVENT, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
///	{ 0, CUSTOMIZE_MESSAGE, (SAP) Customize_message, SERVICES_DEFAULT_PRIORITY },
	{ 0, MESSAGE_RECEIVED, (Telium_callback)Main_, SERVICES_DEFAULT_PRIORITY },
///	{ 0, CUSTOMIZE_CARD_ENTRY, (SAP) ServiceCardEntry, SERVICES_HIGH_PRIORITY },
};
#endif


static const char appName[] = "CLESS";
static const char coldReset[] = "Cold Reset\nFrom ";
static const char warmReset[] = "Warm Reset\nFrom ";
static const char timeToCall[] = "Time to call\nFrom ";
static const char idleMsgPart1_1[] = "1:Std / 2:Specific";
static const char idleMsgPart1_2[] = "3:Settings / 4:DEKDET";
static const char idleMsgPart1_3[] = "red:clean (torn)";
static const char idleMsgPart2_1[] = "5:Trace / 6:Rem DEK";
static const char idleMsgPart2_2[] = "7:DumpDb / 8:TrType";
static const char idleMsgPart2_3[] = "9:loop / Yel:auto15";
static int gs_nScreenIdentifier = 0;

static const char szDate[] = "Date:%.2s/%.2s/%.2s  %.2s:%.2s\n";

static int gs_bCaKeyCheckingDone = FALSE;
#ifndef __TELIUM3__
static int gs_nHeaderEventMask;
#endif
#ifndef DISABLE_OTHERS_KERNELS
static unsigned long gs_ulNoCardTimeOut = 0; // No Card timeout (in milliseconds)
#endif

static int g_bDllTpassLoaded = FALSE;

unsigned short CustApplicationNumber=0x57A9;

extern char buffer12[1024];
extern char buffer13[4000];


/////////////////////////////////////////////////////////////////
//// Functions //////////////////////////////////////////////////

int My_PSQ_Give_Language(void)
{
	const char *lang;

	lang = GetManagerLanguage();
	if (lang != NULL)
	{
        if (strncmp(lang, "fr", 2) == 0)
               return 1;
        if (strncmp(lang, "FR", 2) == 0)
               return 1;
	}

	return 0;	//Forcer le Francais
}

static int give_money_extended_ (NO_SEGMENT no , void * p1, S_MONEYOUT_EXTENDED * moneyout)
{
  S_MONEYOUT_EXTENDED money_out;
 
  // Unused parameters
  (void)no;
  (void)p1;
  
  int n_NbMoney;
  S_MONEY_EXTENDED * ps_x_Money;

  memcpy (&money_out, moneyout, sizeof(S_MONEYOUT_EXTENDED));
  strcpy (money_out.etat_retour[money_out.nb_reponse].libelle , (char*)appName ) ;
  
  ClessSample_Parameters_GetMoneyExtended(&n_NbMoney, &ps_x_Money);
  memcpy(&money_out.etat_retour[money_out.nb_reponse].money[0], ps_x_Money, n_NbMoney * sizeof(S_MONEY_EXTENDED));

  money_out.etat_retour[money_out.nb_reponse].nb_money = n_NbMoney;
  money_out.nb_reponse++;
  memcpy ( moneyout , &money_out , sizeof(S_MONEYOUT_EXTENDED));
  return (FCT_OK) ;
}

/** Enable the refund in the Manager menu.
 * \param    param_out (-O) Eventually ends interrupted transaction
 * \return                                           
 *  STOP
 * \header sdk30.h
 * \source entry.c 
*/
static int select_function_emv_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
	(void)param_in;
	param_out->noappli     = no;
	param_out->rc_payment  = 0x01; //PAIEM_KO;

	return (STOP);
}

/*static void Customize_message(int size, InfosMSG_CUST *infoscust)
{
//  FILE *handle;
  
  // Unused parameters
  (void)size;

  GTL_Traces_TraceDebug("Customize_message : %x", infoscust->num);
  
  // Default value
  infoscust->cr_treatment=NO_CUSTOMIZED_MESSAGE;

  switch(infoscust->num)
  {
    case MESS6:
      ClessSample_Unattended_PrintDump("RETIRER LA CARTE SVP");
      break;

    case MESS111:
      ClessSample_Unattended_PrintDump("\nINTRODUIRE CARTE");
      break;
      
    case MESS256:
      ClessSample_Unattended_PrintDump("ABANDON");
      break;

    case MESS257:
      ClessSample_Unattended_PrintDump("CARTE REJETEE ABANDON");
      break;
      
    case MESS258:
      ClessSample_Unattended_PrintDump("CONTROLES EN COURS");
      break;
      
    case MESS260:
      ClessSample_Unattended_PrintDump("CARTE ARRACHEE");
      break;
      
    case MESS262:
      ClessSample_Unattended_PrintDump("RETIRER LA CARTE SVP");
      break;
      
    case MESS263:
      ClessSample_Unattended_PrintDump("CARTE INVALIDE");
      break;
      
    default:
		break;
  }
}*/


/** Ask application to define its working environment, Manager will select 
 *  common parameters set and adapt its internal processing.
 * \param    param_out (-O) 
 *    - application_type :   
 *      TYP_CARTE (French Bank), TYP_HEALTH(French Health), TYP_EXPORT (Export)
 *    - mask : Key "F" 031 -> Parameters initialisation (0:absent, 1:present)
 *    - response_number : should be incremented
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int give_your_domain_ (NO_SEGMENT no, S_INITPARAMOUT *param_out)
{
	(void) no;

    /// Return application domain to Manager
	/// Setting parameters initialisation
	param_out->returned_state[param_out->response_number].mask = MSK_ALL;
    /// International domain
	param_out->returned_state[param_out->response_number].application_type = TYP_EXPORT;
	param_out->response_number++;

	return (FCT_OK);
}


//===========================================================================
//! \brief This function tests the presence of security DLL. And if it has
//! at least a release 0204.
//===========================================================================
static void	Test_DLL_Security_Presence(void)
{
	int sec_ver;
	int ret; 
	Telium_File_t * printer;

#ifndef _SIMULPC_
	ret = ObjectLoad (OBJECT_TYPE_DLL, "SECURITY");  
#else
	ret =0;
#endif 

	if ((ret != 0) && (ret != OL_ALREADY_LOADED))
	{
		printer=Telium_Fopen("PRINTER","w-");
		if (printer)
		{
			Telium_Pprintf ("\n""Custom \n");
			Telium_Pprintf ("Please LOAD DLL SECURITY\n");

			Telium_Pprintf ("\n\n\n\n\n");
			Telium_Ttestall(PRINTER,0);
			Telium_Fclose(printer);
		}
	}
	else
	{ 		
#ifndef _SIMULPC_
		sec_ver = SEC_Version();
#else
		sec_ver =0x020400;
#endif 

		if (sec_ver<0x020400)
		{
			printer=Telium_Fopen("PRINTER","w-");
			if (printer)
			{
				Telium_Pprintf ("\n""Custom \n");
				Telium_Pprintf ("\n""Please LOAD DLL SECURITY\nWith VERSION >= 0204");

				Telium_Pprintf ("\n\n\n\n\n");
				Telium_Ttestall(PRINTER,0);
				Telium_Fclose(printer);
			}
		}
	}
}



/** Display a message "TPASS DLL NOT LOADED"
 * \header sdk30.h
 * \source entry.c 
*/

static void Display_No_Dll_Msg (void)
{
	MSGinfos tMsg;
	int lg_code;

	// Get the manager language (merchant language)
	lg_code = PSQ_Give_Language();

	ClessSample_Term_Read_Message(STD_MESS_DLL_TPASS, lg_code, &tMsg);
	Helper_DisplayTextMerchant(ERASE, HELPERS_MERCHANT_LINE_2, &tMsg, NOLEDSOFF);
	ClessSample_Term_Read_Message(STD_MESS_NOT_LOADED, lg_code, &tMsg);
	Helper_DisplayTextMerchant(NO_ERASE, HELPERS_MERCHANT_LINE_3, &tMsg, NOLEDSOFF);

	Helper_RefreshScreen(WAIT, HELPERS_MERCHANT_SCREEN);
}



/** Initialise data and create disks, eventually ends interrupted transaction
 *  by returning S_TRANS_OUT.
 * \param    param_out (-O) Eventually ends interrupted transaction
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int after_reset_ (NO_SEGMENT no, S_TRANSOUT *param_out)
{
    unsigned char chgt;
	TYPE_CHGT  type;

	(void)param_out;

#ifndef __TELIUM3__
	gs_nHeaderEventMask = EventHeader (0); // To get the initial Header Event Mask and to set the current to 0
	EventHeader (gs_nHeaderEventMask); // Restore the Header Event mask
#endif

	ssllib_open();		//Kamalssl
	AddProfileSLL();	//Kamalssl


	g_bDllTpassLoaded = (TPass_IsLoaded() == ERR_TPASS_OK);	///< TPass DLL Library
#ifdef __TELIUM3__
    ClessEmv_IsDriverOpened();
#endif

	/// Reset management
	first_init(no, &chgt, (unsigned char *)&type);	///< New software loaded ?
	if (chgt==0xFF)									///< Yes, just loaded with first execution
	{ 
        raz_init(no);								///< Reset indicator downloading
	}
	
	// Try to restore parameters from sav file
	if (ClessSample_Parameters_RestoreParam (&pTreeCurrentParam) != 0)
	{
		GTL_Traces_TraceDebug("after_reset_ : ClessSample_Parameters_RestoreParam ko");
		
		// Read default parameters
		ClessSample_Parameters_ReadDefaultParameters(&pTreeDefaultParam);
		
//		if (ClessSample_Parameters_SaveParam (pTreeDefaultParam) != 0)
//		{
//			GTL_Traces_TraceDebug("after_reset_ : ClessSample_Parameters_SaveParam ko");
//		}
//		else // Parameter has been correctly loaded/saved
		{
			ClessSample_Parameters_InitParameters(&pTreeCurrentParam);
			pTreeCurrentParam = pTreeDefaultParam; // Update pTreeCurrentParam for later use...
			pTreeDefaultParam = NULL;
		}
	}

	// Try to restore the Data Exchange file from the saved file
	if (ClessSample_DataExchange_RestoreFile (&pTreeCurrentDataExchange) != 0)
	{
		ClessSample_DataExchange_InitTlvTree (&pTreeCurrentDataExchange);
		pTreeCurrentDataExchange = NULL;
	}

	
	// Create or restore the batch
	ClessSample_Batch_Restore ();

	ClessSample_Disk_Open_MyDisk();

	// Try to load black list parameters if existing
	ClessSample_BlackListLoad();

	// Indicate CA checking has to be done
	gs_bCaKeyCheckingDone = FALSE;

	// Init the transaction sequence counter
	ClessSample_Batch_InitTransactionSeqCounter(FALSE);

	Test_DLL_Security_Presence();

	ClessSample_Term_Initialise();

	ClessSample_DumpData_InitOutput();

	if (g_bDllTpassLoaded)
	{
		// Set the LEDs into the idle state
		HelperLedsIdleState();
	}
	else
	{
		Display_No_Dll_Msg();
	}

#ifndef DISABLE_UNATTENDED
	if (ClessSample_Unattended_IsUnattendedMechanism())
		ClessSample_Unattended_AfterReset (no);
#endif

#ifdef __TELIUM3__
	HelperLedsIdleState();
#endif

	ClessSample_Goal_Destroy();

	Os__xprintaa("Version cless 0729");//VersionV

//	ParamReset();						//Test17
	FicPara.g_type_connexion = 'I';		//Test17

	ParFile();
	PreFile();
	TraFile();
//	LopFile();

	//hKbd = Telium_Fopen("KEYBOARD", "r*");
	//APEMV_UI_MessageDisplayDelay("BBBB.07",0);

//	appel_caisseUSB();					//Test17
//	Wait_AmountUSB();

	return FCT_OK;
}


/** Report application name to Manager.
 * \param    param_out (-O)
 *    - appname : Application name 
 *    - no : Application number
 *    - response_number : should be incremented
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int is_name_(NO_SEGMENT no, S_ETATOUT *param_out)
{
	strcpy(param_out->returned_state[param_out->response_number].appname, appName);
	param_out->returned_state[param_out->response_number].no_appli = no;
	param_out->response_number++;

	return (FCT_OK);
}



/** Report application state initialise or not to Manager.
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (Initialised), REP_KO (Not initialised)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int is_state_(NO_SEGMENT no, S_ETATOUT *param_out)
{
	int retour; 
#ifndef DISABLE_OTHERS_KERNELS
	S_STATE_PARAM state_param;
#endif

	/// Return application state
	if (g_bDllTpassLoaded)
	{
		param_out->returned_state[param_out->response_number].state.response = REP_OK;
		retour = is_name_ (no, param_out);
		
		// Parameters control checking
		if (!gs_bCaKeyCheckingDone)
		{
			ClessSample_Parameters_CheckCaKeysCrc(pTreeCurrentParam);
			ClessSample_Parameters_CreateSupportedCertificateListForKernel (pTreeCurrentParam, DEFAULT_EP_KERNEL_PAYPASS);
#ifndef DISABLE_OTHERS_KERNELS
			ClessSample_Parameters_CreateSupportedCertificateListForKernel (pTreeCurrentParam, DEFAULT_EP_KERNEL_INTERAC);
#endif
			ClessSample_Parameters_BuildAIDNodes(pTreeCurrentParam);
			gs_bCaKeyCheckingDone = TRUE;

			// Here to be done just one time
			// Test if the VisaWave kernel is present
#ifndef DISABLE_OTHERS_KERNELS
			if(VisaWave_Clear() != KERNEL_STATUS_SERVICE_NOT_AVAILABLE)
				VisaWave_SetVisaWaveKernelPresence();

			ClessSample_VisaWave_SetVisaAsiaGuiMode();
			
			if(ClessSample_VisaWave_IsVisaAsiaGuiMode())
			{
				if(ClessSample_VisaWave_GetNoCardTimeOut(&gs_ulNoCardTimeOut))
				{
					// Set the timeout for the card detection process
					PSQ_read_state_param(&state_param);
					state_param.TimeOutWaitingCardAfterAmount = gs_ulNoCardTimeOut/10;
					PSQ_write_state_param(&state_param);
				}
			}

			ClessSample_Interac_SetInteracGuiMode();

			if(ClessSample_Interac_IsInteracGuiMode())
			{
				if(ClessSample_Interac_GetNoCardTimeOut(&gs_ulNoCardTimeOut))
				{
					// Set the timeout for the card detection process
					PSQ_read_state_param(&state_param);
					state_param.TimeOutWaitingCardAfterAmount = gs_ulNoCardTimeOut/10;
					PSQ_write_state_param(&state_param);
				}
			}
#endif
		}

#ifndef __TELIUM3__
		// Remove Application name on the header
		EventHeader (gs_nHeaderEventMask ^ _APPLI_STATE_);
#endif
	}
	else
	{
		param_out->returned_state[param_out->response_number].state.response = REP_KO;
		retour = is_name_ (no, param_out);
	}

	// Clean up the Torn Transaction log by removing torn records that were not recovered and that have been aged off the log.
	if (ClessSample_Menu_IsAutomaticCleanTornOn())
		if (ClessSample_Torn_IsRecoverySupported())
			ClessSample_Torn_CleanLog();

	return (retour);
}



/** Allows the application to display its idle message when Manager goes back 
 *  to idle (the application should have the higher priority).
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int idle_message_ (NO_SEGMENT no)//KamalCless
{
	GetAllParam();	//Cless_ Get last update if Cust
	GetAllTra();	//Cless_ Get last update if Cust
	GetAllPre();

	if(FicPara.vCam0 != 2)
	{
		APEMV_UI_MessageDisplayDelay ("BONJOUR\nMettre TPV en Ecoute", 0);
	}

	return 0;
}


/** It's activated when pressing on "F" key to select the right application 
 *  to go on menu.
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int more_function_ (NO_SEGMENT nAppliNum)
{
	(void) nAppliNum;

#ifndef DISABLE_UNATTENDED
	if (ClessSample_Unattended_IsUnattendedMechanism())
		if (ClessSample_Unattended_IsUnattendedTerminalWithDisplayWithUCMC ())
			iLIBUCM_Display_Graphic_Start(UCMC_DISPLAY);
#endif

	if (g_bDllTpassLoaded)
		ClessSample_Menu_IdleMenuDisplay();
	else Display_No_Dll_Msg();

#ifndef DISABLE_UNATTENDED
	if (ClessSample_Unattended_IsUnattendedMechanism())
		if (ClessSample_Unattended_IsUnattendedTerminalWithDisplayWithUCMC ())
			iLIBUCM_Display_Graphic_Stop(UCMC_DISPLAY);
#endif

	ClessSample_Goal_Destroy();

#ifdef __TELIUM3__
	HelperLedsIdleState();
#endif
	return (FCT_OK);
}



/** It's activated when key is pressed and terminal is in idle mode. 
 * \param    key_in (I-)
 *    - keycode : Key pressed. 
 * \param    key_out (-O)
 *    - keycode : Key pressed, new key, 0=disable. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int keyboard_event_ (NO_SEGMENT noappli, S_KEY *key_in, S_KEY *key_out)
{
	int nOldStateHeader;

	(void) noappli;

	//Désactivation de keyboard dans l'application sans contact
	key_out->keycode=key_in->keycode;
	return (FCT_OK);



/// Keyboard management
	switch (key_in->keycode)
	{
	case F1: case F4:
		gs_nScreenIdentifier = !gs_nScreenIdentifier;
		key_out->keycode=key_in->keycode;   ///< Return the same key value for keys above !
		break;

	case N1: case N2: case T_CORR:
		if(FicPara.vCam0 == 2){
#ifndef DISABLE_UNATTENDED
		if (!ClessSample_Unattended_IsUnattendedMechanism())
#endif
		{
			nOldStateHeader = StateHeader(0);
		
			// Start the transaction
			ClessSample_ExplicitSelection_Process (key_in->keycode == N2, key_in->keycode == T_CORR);//KamalCless
			FicPara.vCam0 = 0;
			PutAllParam();
			key_out->keycode = T_ANN;

			StateHeader(nOldStateHeader);
		}

#ifndef DISABLE_UNATTENDED
		else
		{
			key_out->keycode = 0;               ///< Inhibit these keys to Manager for International domain
		}
#endif
		}
		break;

	case N3:
		nOldStateHeader = StateHeader(0);
		ClessSample_Menu_SelectParameterFile();
		key_out->keycode = T_ANN;
		StateHeader(nOldStateHeader);
		break;

	case N4:
		nOldStateHeader = StateHeader(0);
		ClessSample_Menu_SelectDataExchangeParamsFile();
		key_out->keycode = T_ANN;
		StateHeader(nOldStateHeader);
		break;

	case N5:
		Wait_AmountUSB();
		/*
		nOldStateHeader = StateHeader(0);
		ClessSample_Menu_TestTraces();
		key_out->keycode = T_ANN;
		StateHeader(nOldStateHeader);
		*/
		break;

	case N6:
		nOldStateHeader = StateHeader(0);
		ClessSample_Menu_EraseDataExchangeParams();
		key_out->keycode = T_ANN;
		StateHeader(nOldStateHeader);
		break;

	case N7:
		// DumpDb
		nOldStateHeader = StateHeader(0);
		ClessSample_Menu_TestTransactionDumpDatabase();
		key_out->keycode = T_ANN;
		StateHeader(nOldStateHeader);
		break;

	case N8:
		// TrType
		nOldStateHeader = StateHeader(0);
		ClessSample_Menu_TestInputTransactionType();
		key_out->keycode = T_ANN;
		StateHeader(nOldStateHeader);
		break;

	case N9:
		// Loop
		nOldStateHeader = StateHeader(0);
		ClessSample_Menu_TestTransactionLoop();
		key_out->keycode = T_ANN;
		StateHeader(nOldStateHeader);
		break;

	case N0:
	case T_VAL : case T_POINT : 
		key_out->keycode = 0;               ///< Inhibit these keys to Manager for International domain
		break;
	case T_ANN:
		if (!ClessSample_Menu_IsAutomaticCleanTornOn())
			if (ClessSample_Torn_IsRecoverySupported())
				ClessSample_Torn_CleanLog();
		key_out->keycode=key_in->keycode;
		break;
	case F2 : case F3 :
	case NAVI_CLEAR : case NAVI_OK :
	case UP : case DOWN :
	case T_F :                              ///< do not filter F key and return the same key ! 
		key_out->keycode=key_in->keycode;   ///< Return the same key value for keys above ! 
		break; 
	default :
		key_out->keycode=key_in->keycode;
		break;
	}

	return (FCT_OK);
}



/** It's activated on "F" key: Consultation->State. 
 *  To print terminal content.  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int state_ (NO_SEGMENT no)
{
	//Telium_Date_t date;
   	object_info_t infos;
	Telium_File_t     *hPrinter;
	
	/// Print application info
	ObjectGetInfo(OBJECT_TYPE_APPLI, no, &infos);       ///< Retrieve application info

	hPrinter=Telium_Fopen( "PRINTER", "w-*" );                 ///< Open printer driver
	if (hPrinter!=NULL) 
	{	
		Telium_Pprintf("\x1b""E%s\n""\x1b""F",appName);        ///< Print application name
/*		Telium_Pprintf("         STATE         \n"
			    "Application used as\n"
			    "IngeDev Template\n\n");
		Telium_Read_date(&date);                               ///< Print date and time
		Telium_Pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);*/
		Telium_Pprintf("File    : %s\n",infos.file_name);      ///< Print application file name
		Telium_Pprintf("CRC     : %04x\n",infos.crc);          ///< Print application CRC
		Telium_Ttestall(PRINTER, 0);	  

		Telium_Fclose(hPrinter);                               ///< Close printer driver
	}
	
	return FCT_OK;
}



/** It's activated on "F" key: Consultation->Transactions. 
 *  To print transactions total receipt. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int consult_ (NO_SEGMENT no)
{
	DATE date;
	FILE *hPrinter;
	
	/// Print daily totals
	hPrinter=fopen("PRINTER", "w-*");                    ///< Open printer driver
	if (hPrinter!=NULL)
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName);        ///< Print application name
		pprintf("        CONSULT        \n"
			    "Print daily totals here\n"
			    "Number of Debit/Credit \n"
				"Totals of Debit/Credit \n"
				"Number of Cancel\n\n");
		read_date(&date);                                ///< Print date and time
		pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
	
		ttestall(PRINTER, 3*100);
		fclose(hPrinter);                                ///< Close printer driver
	}

	return FCT_OK;
}*/



/** It's activated on "F" key: Consultation->Call->Planning of Call. 
 *  To print call schedule receipt. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int mcall_ (NO_SEGMENT no)
{
	DATE date;
	FILE *hPrinter;
	
	/// Print call schedule
	hPrinter=fopen("PRINTER", "w-*");                     ///< Open printer driver
	if (hPrinter!=NULL)
	{ 
		pprintf("\x1b""E%s\n""\x1b""F", appName);         ///< Print application name
		pprintf("         MCALL         \n"
	            "Planning of call here  \n"
       			"Time release batch     \n"
				"Time loading parameters\n"
				"Time loading hotlist\n\n");
		read_date(&date);                                 ///< Print date and time
		pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
		
		ttestall(PRINTER, 3*100);
		fclose(hPrinter);                                 ///< Close printer driver
	}

	return FCT_OK;
}*/



/** Do you need the peripherals at the next call of time_function()?.
 *  It's call every minute.
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (Manager closes all peripherals), REP_KO (Manager keeps all peripherals opened)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_time_function_ (NO_SEGMENT no, S_ETATOUT *param_out)
{
	int retour;

	/// Peripherals needed?
	param_out->returned_state[param_out->response_number].state.response=REP_OK;
	retour = is_name_ (no, param_out);

#ifdef __TELIUM3__
	HelperLedsIdleState();
#endif

	return(retour);
}



/** Allow application to execute its own periodical process. 
 *  It's call every minute. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int time_function_ (NO_SEGMENT no)
{	
	/// Periodical function in progress 
	fopen("DISPLAY","w");                 ///< Open display driver
	printf(timeToCall);
	printf(appName);
	
	ttestall(0, 1*100);
	fclose(stdout());                     ///< Close display driver    
	
	return (FCT_OK);
}*/



/** It's activated on "F" key: Initialisation->Parameters->List.
 *  Each time Manager wants to change its own parameters.
 * \param    param_out (-O)
 *    - mask : Key "F" 031 -> Parameters modification (0:accepting, 1:refusing)
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_change_init_(NO_SEGMENT no, S_ETATOUT *param_out)
{
	S_ETATOUT etatout;
	int       retour;
	memcpy(&etatout, param_out, sizeof(etatout));

	/// accept all 
	etatout.returned_state[etatout.response_number].state.mask=0;
	memcpy(param_out,&etatout,sizeof(etatout));
	retour = is_name_ (no, param_out);
	return(retour);
}



/** It's activated on "F" key: Initialisation->Parameters->List.
 *  Each time Manager changed its own parameters.
 * \param    param_in (I-)
 *    - mask : Key "F" 031 -> Parameters modification (0:not modified, 1:modified)
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int modif_param_(NO_SEGMENT noappli, S_MODIF_P *param_in)
{
	S_MODIF_P param_changed;
	
	memcpy(&param_changed, param_in,sizeof(param_changed));
	fopen("DISPLAY","w");
	printf("MODIF_PARAM\n%04x",(int)param_changed.etatout.returned_state[0].state.mask);
	ttestall(0,200);
	fclose(stdout());
	return(FCT_OK);
}*/



/** It's activated each time Manager wants to run a downloading session (local or remote).
 *  "F" key: Evolution->Load->Local or Evolution->Remote Load
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (App authorises donwloading process), REP_KO (App refuses any downloading process)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_evol_pg_ (NO_SEGMENT no, S_ETATOUT *param_out)
{
	int retour;

    /// Downloading process allowed?
	param_out->returned_state[param_out->response_number].state.response=REP_OK;
	retour = is_name_ (no, param_out);

	return(retour);
}



/** It's activated each time Manager wants to delete an application.
 *  "F" key: Deletion
 * \param    param_out (-O)
 *    - response : 
 *      DEL_YES (App authorises deletion process), DEL_NO (App refuses any deletion process)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_delete_ (NO_SEGMENT no, S_DELETE *param_out)
{
	(void) no;

	/// Deletion process allowed?
	param_out->deleting=DEL_YES;

	return (FCT_OK);
}



/** Manager reports parameters file received from LLT.
 *  It's activated upon reception of a parameter file by the manager.
 * \param    param_in (I-)
 *    - volume_name : SYSTEM (File loaded in CFS), HOST (File loaded in DFS).
 *    - file_name : Application file name
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int file_received_ (NO_SEGMENT no, S_FILE *param_in)
{
//	unsigned char * pSha;
//	int nCRCLength;
	int nResult;
//	int nIndex;
//	char StrBuff[100];
//	char TmpStr[10];
	
	(void) no;

	// Try to read parameter file and store it into an internal TLV tree structure
/*	nResult = ClessSample_Parameters_ReadXMLFile((char*)param_in->volume_name, (char*)param_in->file_name, &pTreeCurrentParam);
	if (nResult == STOP) // Inputed file is a parameter file 
	{
		// File has been received
		GTL_Traces_DiagnosticText ("CLESSCUST.PAR file received\n");
		
		// Prepare all the information (before the transaction) for each AID
		
		// Trace prepared data
		ClessSample_Parameters_Trace_Parameter_AID_Structure();
		
		// Compute the configuration CRC
		ClessSample_Parameters_Compute_Config_CRC(&pTreeCurrentParam, &nCRCLength, &pSha);
		{
			sprintf(StrBuff, "Parameters CRC : \n");
			
			for (nIndex=0; nIndex<nCRCLength; nIndex++)
			{
				sprintf(TmpStr, "%02x", pSha[nIndex]);
				strcat(StrBuff, TmpStr);
			}
		    GTL_Traces_TraceDebug("%s", StrBuff);
		}
		return (nResult);
	}*/

	// Check if the file was a Data Exchange file
/*	nResult = ClessSample_DataExchange_ReadXMLFile((char*)param_in->volume_name, (char*)param_in->file_name, &pTreeCurrentDataExchange);

	if (nResult == STOP) // Inputed file is a Data Exchange file 
	{
		///ClessSample_DumpData_DumpTlvTreeIndented (pTreeCurrentDataExchange, "DUMP MCW XML");
		GTL_Traces_DiagnosticText ("DEKDET.PAR file received\n");
		return (nResult);
	}*/

	// Try to read black List parameter
	nResult = ClessSample_BlackListGetNewFile(param_in->volume_name, param_in->file_name);
	if (nResult == STOP) // Inputed file is a Black list parameter file 
	{
		GTL_Traces_DiagnosticText ("CLESSBLACK.PAR file received\n");
		return (nResult);
	}
	
	return (nResult);
}



/** Inter application messaging.
 *  It's activated each time Manager received a message in its mailbox for this application.
 * \param    param_in (I-)
 *    - sender : Sender ID.
 *    - receiver : Receiver ID.
 *    - type : IAM type.
 *    - length : Message length.
 *    - value : Message received.
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int message_received_ (NO_SEGMENT no, S_MESSAGE_IAM *param_in)
{
	FILE *prt;

	/// Print message received from application 2
	prt=fopen("PRINTER","w-");                                           ///< Open printer driver
	pprintf("\x1b""E%s\n""\x1b""F", appName);      
	pprintf ("Message IAM :\n");
	pprintf ("S:%04X R:%04X\n", param_in->sender, param_in->receiver);   ///< USER2 to TEMPLATE
	pprintf ("IAM Type : %04X \n\n", param_in->type);

	pprintf("%s\n\n\n\n\n\n", param_in->value);                          ///< Print the message received
	ttestall(PRINTER, 2*100);
	fclose(prt);                                                         ///< Close printer driver

	return (FCT_OK);
}*/



/** 
 *  It's activated when a card is inserted, swiped or manually entry.
 *  Ask the application if the card need a specific processing.
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (card processing), REP_KO (no card processing)  
 *  Only one application wants to process the card, manager calls CARD_INSIDE entry.
 *  More application wants to process the card, manager asks for card removal.
 *  If no application wants to process the card, manager goes on with selection process. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_card_specific_ (NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out)
{
	int ret; 

	(void) param_in;

	/// Return application state
	param_out->returned_state[param_out->response_number].state.response = REP_KO;
	ret = is_name_ (no, param_out);
	
	return (ret);
}



/** 
 *  It's activated when an application has chosen to treat this card has specific.
 *  The transaction is done here.
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 *  If an application retourns STOP, polling is stopped and manager asks for card removal.
 *  The application is in charge to ask for amount and currency if needed.
 * \return   
 *  STOP    Card accepted and transaction process done, polling is stop. 
 *  FCT_OK  Card refused and poll the next application.
 * \header sdk30.h
 * \source entry.c 
*/
/*static int card_inside_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
    bool card_accepted = TRUE;

	if (card_accepted)
	{
	/// Return transaction status
	param_out->rc_payment = PAY_OK;               ///< Transaction done, polling is stop
	return (STOP);
	}
	else
	{
		return (FCT_OK);                          ///< Card refused, poll the next application
	}
}*/



/** 
 *  Ask application to recognise the mag, smart or manually card in order to be
 *  a candidate.
 * \param    param_out (-O)
 *    - cardappnumber : 1 = Card accepted, 0 = Card rejected 
 *    - cardapp : 
 *      CARD_PROCESSED (low priority) 
 *      CARD_RECOGNIZED (medium priority) 
 *      CARD_PRIORITY (high priority)
 *    - appname : Application name 
 *    - no : Application number
 *    - response_number : should be incremented
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int is_for_you_after_ (NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out)
{
	
	/// case of chip card
	if (param_in->support == CHIP_SUPPORT)
	{
		if(param_in->power_on_result == 0)
		{
			/// accept this card 
			param_out->returned_state[param_out->response_number].cardappnumber = 1;
			param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PROCESSED;
		}
		else
		{
			/// reject the card
			param_out->returned_state[param_out->response_number].cardappnumber = 0;
		}
	}

	/// case of stripe 2 card
	if (param_in->support == TRACK2_SUPPORT)
	{
		/// accept this card 
		param_out->returned_state[param_out->response_number].cardappnumber = 1;
		param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
	}
	
	/// case of Card Number Manual entry
	if (param_in->support == OPERATOR_SUPPORT)
	{
		/// accept this card 
		param_out->returned_state[param_out->response_number].cardappnumber = 1;
		param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
	}

	/// give my application name 
	strcpy (param_out->returned_state[param_out->response_number].appname, appName) ;
	/// give my application number
	param_out->returned_state[param_out->response_number].no_appli = no;
	/// give my card name
	strcpy (param_out->returned_state[param_out->response_number].cardapp [0].cardappname, "Template") ;
	/// increment the response number 
	param_out->response_number++;

	return (FCT_OK);
}*/



/** 
 * ¨Process a non EMV chip card or a magnetic card or manual entry transaction.
 * \param    param_out (-O)
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int debit_non_emv_ (NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out)
{
	FILE *prt;
	int i;

	prt  = fopen("PRINTER", "w-");
	
	/// case of chip card 
	if ( param_in->support == CHIP_SUPPORT )
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName); 
		if (param_in->historical_bytes.length != 0)
		{
			pprintf("Atr:\n");
			for (i=0; i<param_in->historical_bytes.length; i++)
			{
				pprintf("%02X ", param_in->historical_bytes.historic[i]);
			}
		}
		else
		{
			pprintf("Synchronous card\n");
			pprintf("or Chip mute\n");
		}
		pprintf("\n\n\n\n\n\n");
	}

	/// case of stripe 2 card
	if ( param_in->support == TRACK2_SUPPORT )
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName); 
		pprintf("Track2:\n%s\n\n\n\n\n\n", param_in->track2); 
	}
	
	/// case of Card Number Manual entry
	if ( param_in->support == OPERATOR_SUPPORT )
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName); 
		pprintf("Manual Entry:\n%s\n\n\n\n\n\n",param_in->track2); 
	}
	
	ttestall(PRINTER,2*100);
	fclose(prt);

	param_out->noappli      = no;                 ///< Return application number
	param_out->rc_payment = PAY_OK;               ///< Transaction done
	return (FCT_OK);
}*/



/** 
 * Enable CGUI mode of the manager for this application.
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int give_your_specific_context_(const NO_SEGMENT AppliNum, S_SPECIFIC_CONTEXT* pParamOut)
{
	// Initialise the output parameter
	memset(&pParamOut->returned_state[pParamOut->response_number], 0,
		sizeof(pParamOut->returned_state[pParamOut->response_number]));

#ifdef __TELIUM3__
	strcpy(pParamOut->returned_state[pParamOut->response_number].appname, "822449----");
#else
	strcpy(pParamOut->returned_state[pParamOut->response_number].appname, "844084----");
#endif

	pParamOut->returned_state[pParamOut->response_number].no_appli = AppliNum;
	pParamOut->returned_state[pParamOut->response_number].mask = 0;
	pParamOut->returned_state[pParamOut->response_number].type = 0;
	pParamOut->returned_state[pParamOut->response_number].support = 0;
	pParamOut->returned_state[pParamOut->response_number].cam = 0;

	// The application is CGUI compliant
	pParamOut->returned_state[pParamOut->response_number].cgui = (CGUI_MASK);
	pParamOut->response_number++;

	return FCT_OK;
}



/** 
 * ¨Get the contactless information for transaction.
 * \param    param_out (-O)
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

/*
static int cless_give_info_ (NO_SEGMENT no, S_TRANSIN * param_in, S_CLESS_GIVEINFO * param_out)
{
	unsigned char ucCurrencyCode[2];
	int nTransactionType;
	int nTransactionCashBack;
	unsigned long ulAmountOtherBin = 0;
	unsigned char ucTransactionType;
	unsigned char ucTransactionCashBack;
	unsigned char ucAmountAuthPresent;


	(void) no;
	nTransactionType = 0;
	nTransactionCashBack = 0;
	ucAmountAuthPresent = SAMPLE_TAG_ABSENT;

	ClessSample_Common_SetTransactionMode (CLESS_SAMPLE_TRANSACTION_MODE_IMPLICIT);

	ClessSample_Customisation_SetUsedPaymentScheme (CLESS_SAMPLE_CUST_UNKNOWN);
	ClessSample_Customisation_SetDoubleTapInProgress (FALSE);
	
	// Init the language structure
	ClessSample_GuiState_InitLanguageStructure();
	
	// Prepare maximum transaction data for kernel purpose before card presentation
	// Input parameters
	if (!ClessSample_Fill_InitSharedBufferWithKernels (&g_pKernelSharedBuffer))
	{
		GTL_Traces_TraceDebug("cless_give_info_ : ClessSample_Fill_InitSharedBufferWithKernels failed");
		goto End;
	}

	// Add transaction data (amount, date, time, etc).
	ucCurrencyCode[0] = param_in->currency.code[0] - 0x30;
	ucCurrencyCode[1] = ((param_in->currency.code[1] - 0x30) << 4) + (param_in->currency.code[2] - 0x30);

	// Choose the transaction type
	if (ClessSample_Menu_IsEnableInputTransactionType()) // Is transactionType must be inputed
	{
		// Input nTransactionType
		ClessSample_Menu_TransactionTypeMenuDisplay (&nTransactionType, &nTransactionCashBack);

		if ((nTransactionType == CLESS_SAMPLE_TRANSACTION_TYPE_DEBIT) && (nTransactionCashBack))
		{
			// If Amount = 0
			if (param_in->amount == 0)
			{
				// No Amount other entry possible or must be set to 0 (Initial amount inputed must be egal to amount + amount other)
				ulAmountOtherBin = 0;
			}
			else
			{
				// => amount other must inputed
				if (!ClessSample_Common_AmountEntry (TRUE, param_in->currency.nom, &ulAmountOtherBin))
				{
					// Amount other entry failed
					GTL_Traces_TraceDebug ("cless_give_info_ : amount other entry failed");
					nTransactionType = -1;
				}
			}
		}

		// Anti-bug:
		if (ulAmountOtherBin > param_in->amount)
		{
			// Amount other is greater than amount authorised
			GTL_Traces_TraceDebug ("cless_give_info_ : amount other is greater than amount authorised");
			nTransactionType = -1; // Error
		}
	}
	else
	{
		// Get the transaction type
		if (param_in->transaction == CREDIT_TR)
			nTransactionType = CLESS_SAMPLE_TRANSACTION_TYPE_REFUND;
		else
			nTransactionType = CLESS_SAMPLE_TRANSACTION_TYPE_DEBIT;
	}

	// Error management
	if (nTransactionType == -1)
	{
		// Indicate an error occured to the operator
		ClessSample_GuiState_DisplayScreen (CLESS_SAMPLE_SCREEN_ERROR, -1, -1);
		goto End;
	}

	// Save CLESS_GIVE_INFO input data for future use
	///ClessSample_Fill_PrepareAndSaveClessGiveInfoTransactionData ((param_in->entry != NO_ENTRY), (unsigned char)nTransactionType, (unsigned char)nTransactionCashBack, ucCurrencyCode, param_in->currency.posdec, param_in->currency.nom, param_in->amount, ulAmountOtherBin);
	
	ucTransactionType = ((unsigned char)nTransactionType);
	ucTransactionCashBack = ((unsigned char)nTransactionCashBack);

	if (param_in->entry != NO_ENTRY)
		ucAmountAuthPresent = SAMPLE_TAG_PRESENT;

	ClessSample_Fill_PrepareAndSaveClessGiveInfoTransactionStaticData (ucAmountAuthPresent, param_in->amount,
																SAMPLE_TAG_PRESENT, ulAmountOtherBin,
																SAMPLE_TAG_PRESENT, ucCurrencyCode,
																SAMPLE_TAG_PRESENT, &(param_in->currency.posdec),
																SAMPLE_TAG_PRESENT, &ucTransactionType,
																TRUE, 0,
																&ucTransactionCashBack, param_in->currency.nom);


	// Set the date and time with the current values
	ClessSample_Fill_PrepareAndSaveClessGiveInfoTransactionDynamicData (TRUE, 0, TRUE, 0);
	
	// Fill the output structure with the data to be used for application selection
	if (!ClessSample_Fill_GiveInfo (param_out, &pTreeCurrentParam))
	{
		GTL_Traces_TraceDebug("cless_give_info_ : ClessSample_Fill_GiveInfo failed");
		goto End;
	}

	if (ClessSample_VisaWave_IsVisaAsiaGuiMode())
	{
		// Start timer
		VisaWave_StartDetectionTimer();
		ClessSample_VisaWave_GetLastTransactionData();
	}

	if(ClessSample_Interac_IsInteracGuiMode())
	{
		// Start timer
		Interac_StartDetectionTimer();
	}
End:
	return (FCT_OK);
}
*/

/** 
 * ¨Process a Cless debit with AID already selected.
 * \param    param_out (-O)
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*
static int cless_debit_aid_ (NO_SEGMENT no, unsigned int nSize, void * pData)
{
	// Specific variables to manage share buffer
	int nResult = C_CLESS_CR_END;
	int nKernelToUse;
	T_SHARED_DATA_STRUCT * pSharedStruct;


	(void) no;
	(void) nSize;

	VisaWave_SetpayWaveFallBack(FALSE);

	if(ClessSample_VisaWave_IsVisaAsiaGuiMode())
	{
		// "No Card" message will not be displayed
		VisaWave_SetDisplayNoCard(FALSE);
	}

	if(ClessSample_Interac_IsInteracGuiMode())
	{
		// "No Card" message will not be displayed
		Interac_SetDisplayNoCard(FALSE);
	}

Restart:

	// Input parameters
	pSharedStruct = ((T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData)->pDataStruct;

	// Indicates the cless kernel is not yet known
	ClessSample_Customisation_SetUsedPaymentScheme (CLESS_SAMPLE_CUST_UNKNOWN);
	
	// Input parameters (g_pKernelSharedBuffer has been initialised in the CLESS_GIVE_INFO service, just clear it)
	GTL_SharedExchange_ClearEx (g_pKernelSharedBuffer, FALSE);

	// Fill the shared buffer with the transaction data
	if (!ClessSample_Fill_TransactionGenericData (g_pKernelSharedBuffer))
	{
		GTL_Traces_TraceDebug("cless_debit_aid_ : ClessSample_Fill_TransactionGenericData failed");
		return (nResult);
	}


	// Dump data provided on CLESS_DEBIT_AID service (content of shared buffer)
	///ClessSample_DumpData_DumpSharedBufferWithTitle(pSharedStruct, "CLESS_DEBIT_AID");
	
	// Fill buffer with AID related data
	if (!ClessSample_Fill_AidRelatedData (g_pKernelSharedBuffer, pSharedStruct, &nKernelToUse))
	{
		GTL_Traces_TraceDebug("cless_debit_aid_ : ClessSample_Fill_AidRelatedData failed");
		return (nResult);
	}

	// Call kernel in relationship with AID
	switch (nKernelToUse)
	{
	case DEFAULT_EP_KERNEL_PAYPASS :
		// Clear input data for next call
		GTL_SharedExchange_Clear(pSharedStruct);
	
		nResult = ClessSample_PayPass_PerformTransaction(g_pKernelSharedBuffer);
		break;
		
	case DEFAULT_EP_KERNEL_VISA :
		if(VisaWave_isVisaWaveProcessing())
		{
			nResult = ClessSample_VisaWave_PerformTransaction(g_pKernelSharedBuffer);
			if(nResult == VISAWAVE_STATUS_PAYWAVE_CARD)
			{
				VisaWave_SetpayWaveFallBack(TRUE);
				goto Restart;
			}
			else
			{
				// Clear input data for next call
				GTL_SharedExchange_Clear(pSharedStruct);
			}
		}
		else
		{
			GTL_SharedExchange_Clear(pSharedStruct);
			nResult = ClessSample_payWave_PerformTransaction(g_pKernelSharedBuffer);
		}
		break;
				
	case DEFAULT_EP_KERNEL_AMEX :
		GTL_SharedExchange_Clear(pSharedStruct);
		nResult = ClessSample_ExpressPay_PerformTransaction(g_pKernelSharedBuffer);	
		break;

	case DEFAULT_EP_KERNEL_DISCOVER :
		GTL_SharedExchange_Clear(pSharedStruct);
		nResult = ClessSample_Discover_PerformTransaction(g_pKernelSharedBuffer);	
		break;

	case DEFAULT_EP_KERNEL_INTERAC :
		GTL_SharedExchange_Clear(pSharedStruct);
		nResult = ClessSample_Interac_PerformTransaction(g_pKernelSharedBuffer);
		break;

	default:
    	GTL_Traces_TraceDebug("Unknown Kernel to use in cless_debit_aid() : %x", nKernelToUse);
		break;
	}

	return (nResult);
}
*/


/** 
 * \brief This entry point is called after the contact less transaction (or when a contact transaction is initiated).
 * It can be used to close peripheral (that had been opened in the CLESS_GIVE_INFO entry point for example) or doing 
 * any other treatments.
 * \param[in] nAppliNum Application Number.  
 * \return   
 *  	- \ref FCT_OK always.
 */
/*
static int cless_end_ (NO_SEGMENT nAppliNum)
{
	(void) nAppliNum;
	MSGinfos tMsg;
	int nTimeout, nLang;
	
	if(ClessSample_VisaWave_IsVisaAsiaGuiMode() && VisaWave_GetDisplayNoCard())
	{
		nLang = PSQ_Give_Language();

		nTimeout = GTL_StdTimer_GetRemaining(VisaWave_GetDetectionTimer(), gs_ulNoCardTimeOut/10);
		if (nTimeout == 0)
		{
			ClessSample_Term_Read_Message(VISAWAVE_MESS_NO_CARD, nLang, &tMsg);
			Helper_DisplayTextCustomer(ERASE, HELPERS_CUSTOMER_LINE_2, &tMsg, CLESSSAMPLE_ALIGN_CENTER, LEDSOFF);
			Helper_RefreshScreen(WAIT, HELPERS_CUSTOMER_SCREEN);
		}
	}
		
	if(ClessSample_Interac_IsInteracGuiMode() && Interac_GetDisplayNoCard())
	{
		nLang = PSQ_Give_Language();

		nTimeout = GTL_StdTimer_GetRemaining(Interac_GetDetectionTimer(), gs_ulNoCardTimeOut/10);
		if (nTimeout == 0)
		{
			HelperErrorSequence (WITHBEEP);
			ClessSample_Term_Read_Message(INTERAC_MESS_NO_CARD, nLang, &tMsg);
			Helper_DisplayTextCustomer(ERASE, HELPERS_CUSTOMER_LINE_2, &tMsg, CLESSSAMPLE_ALIGN_CENTER, LEDSOFF);
			Helper_RefreshScreen(WAIT, HELPERS_CUSTOMER_SCREEN);
		}
	}

	ClessSample_Common_SetTransactionMode (CLESS_SAMPLE_TRANSACTION_MODE_UNKNOWN);

	return (FCT_OK);
}
*/


/** 
 * \brief Services registration and priority.  
 *  For all services except idle_message, priority => 0x00 highest and 0xFF lowest
 *  For idle_message, priority => 0x00 lowest 0xFF highest
 * \header sdk30.h
 * \source entry.c 
*/
static int give_interface_ (unsigned short AppliNum, void* pParamIn, void* pParamOut)
{
	int i;

	(void)pParamIn;
	(void)pParamOut;

#ifndef DISABLE_UNATTENDED
	if (ClessSample_Unattended_IsUnattendedMechanism())
	{
		ClessSample_Unattended_InitTransactionStartData ();

		for(i = 0; i < (int)(sizeof(ServicesUnattended) / sizeof(ServicesUnattended[0])); i++)
			ServicesUnattended[i].appli_id = AppliNum;

		Telium_ServiceRegister((sizeof(ServicesUnattended) / sizeof(ServicesUnattended[0])), ServicesUnattended);

		// Security DLL open 
		SEClib_Open();
	}
	else
#endif
	{
		for(i = 0; i < (int)(sizeof(ServicesStandard) / sizeof(ServicesStandard[0])); i++)
			ServicesStandard[i].appli_id = AppliNum;

		Telium_ServiceRegister((sizeof(ServicesStandard) / sizeof(ServicesStandard[0])), ServicesStandard);

		// Security DLL open 
		SEClib_Open();
	}

	return FCT_OK;
}



/** 
 *  \brief Function called for customisation of application selection processing.
 *  \param[in] nSize Size of \a pData.
 *  \param[in] pData Data sent by the caller.
 * 	\return
 *		- CLESS_CUST_DEFAULT to use the default processing. 
 *		- CLESS_CUST_RETRY_WITH_CLESS if the transaction shall be restarted.
 *		- CLESS_CUST_RETRY_WITHOUT_CLESS if transaction shall be restarted without cless.
 *		- CLESS_CUST_STOP if the transaction shall be stopped.
 *		- CLESS_CUST_NEXT_METHOD if next application selection method shall be used (if present). 
 *		- CLESS_CUST_CONTINUE_METHOD if next application selection criteria shall be used. 
 */

/*static int custom_appli_selection_proc (unsigned int nSize, void * pData)
{
	T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;
	
	(void)nSize;
	pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;

	return (ClessSample_Customisation_CustAsProc(pSharedStruct->pDataStruct));
}*/


//! \brief This function is called to customise the GUI during the DLL processing.
//! \param[in] pDataStruct Shared buffer containing data necessary to customise the step.
//! \return
//!	- \ref CLESS_CUST_DEFAULT if default DLL GUI shall be executed.
//!	- \ref CLESS_CUST_CONTINUE if application made customisation and default DLL GUI shall not be executed.

/*static int custom_selection_gui (unsigned int nSize, void * pData)
{
	T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;
	
	(void)nSize;
	pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;

	if(ClessSample_VisaWave_IsVisaAsiaGuiMode())
		return (ClessSample_Customisation_VisaAsia_SelectionGui (pSharedStruct->pDataStruct));
		///return (ClessSample_Customisation_SelectionGui(pSharedStruct->pDataStruct));
	else if(ClessSample_Interac_IsInteracGuiMode())
		return (ClessSample_Customisation_Interac_SelectionGui(pSharedStruct->pDataStruct));
	else
		return(CLESS_CUST_DEFAULT);
}*/

#ifdef __TELIUM3__
static T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT* __GetSharedStructFromServiceCall(void *pData)
{
   T_KERNEL_SERVICE_CALL_LOCAL_MEMORY *param = pData;

   if(param->sc.pDataStruct != NULL)
   {
      param->shared.nPtrData = param->data;
      param->sc.pDataStruct = &param->shared;
      return &param->sc;
   }
   else
      return NULL;
}

#else
static T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT* __GetSharedStructFromServiceCall(void *pData)
{
   return (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;
}
#endif

/** 
 * \brief This service is called by the contactless kernels for customisation processing.
 * This is the application that provide kernel the service and the application type to call for customisation. 
 * \param[in] nSize Size of \a pData (not used as \a pData is a shared service call struct).
 * \param[in,out] pData Data buffer to be used to get and provide data to the kernel.  
 * \return   
 *  	- \ref FCT_OK always.
 */
static int custom_kernel_ (unsigned int nSize, void * pData)
{
	int nResult;
	T_SHARED_DATA_STRUCT * pSharedStruct;

	(void) nSize;
	
	perflog("MG\tPP_CUST\tcustom_kernel_");
	pSharedStruct = (__GetSharedStructFromServiceCall(pData))->pDataStruct;

	// Call the customisation depending on the kernel used
    nResult = ClessSample_Customisation_Process (pSharedStruct);
	perflog("MG\tPP_CUST\tExit custom_kernel_");
    
	return (nResult);
}

int cu_custom_kernel_ (unsigned int nSize, void * pData)
{
	return custom_kernel_ (nSize,pData);
}


/** 
 * \brief This service is called by the contactless paypass kernel for Data Exchange processing.
 * The the application provides the kernel with the service and the application type to call for customisation. 
 * \param[in] nSize Size of \a pData (not used as \a pData is a shared service call struct).
 * \param[in,out] pData Data buffer to be used to get and provide data to the kernel.  
 * \return   
 *  	- \ref FCT_OK always.
 */

static int de_kernel_ (unsigned int nSize, void * pData)
{
	int nResult;
	T_SHARED_DATA_STRUCT * pSharedStruct;

	(void) nSize;
	
	pSharedStruct = (__GetSharedStructFromServiceCall(pData))->pDataStruct;

	// Call the customisation depending on the kernel used
    nResult = ClessSample_Customisation_Data_Exchange (pSharedStruct);
    
	return (nResult);
}

int cu_de_kernel_ (unsigned int nSize, void * pData)
{
	return de_kernel_ (nSize,pData);
}



/** Inter application messaging.
 *  It's activated each time Manager received a message in its mailbox for this application.
 * \param    param_in (I-)
 *    - sender : Sender ID.
 *    - receiver : Receiver ID.
 *    - type : IAM type.
 *    - length : Message length.
 *    - value : Message received.
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int message_received_(NO_SEGMENT AppliNum, S_MESSAGE_IAM* pParamIn)
{	
	(void)AppliNum;
	(void)pParamIn;
	Telium_File_t * hDisplay;

	//APEMV_UI_MessageDisplayDelay("Message_received",3);

	ClessSample_ComEventSetSerialRequest();
	
    hDisplay = Telium_Fopen("DISPLAY","w");
    if(!memcmp(pParamIn->value,"ABCDEF",6))
    {
    	int nOldStateHeader;
    	GetAllParam();	//Cless_ Get last update if Cust
    	GetAllTra();	//Cless_ Get last update if Cust
    	GetAllPre();	//Cless_ Get last update if Cust


    	if(FicPara.vCam0 == 2)
    	{
    		memset(buffer12,'\0',sizeof(buffer12));
    		memset(buffer13,'\0',sizeof(buffer13));

    		memset(&StructInfoCaisse[0],0,sizeof(MSG_CAISSE));
    		memset(&StructInfoCaisse[1],0,sizeof(MSG_CAISSE));


    		memset(&E_Transac8583,0x00,sizeof(E_Transac8583));
    		memset(&R_Transac8583,0x00,sizeof(R_Transac8583));

    		//memset(&StructInfoPayment ,0x00,sizeof(StructInfoPayment));


    		memcpy(&StructInfoCaisse[0],&SaveLastInfoCaisse,sizeof(MSG_CAISSE));//Cless
    		nOldStateHeader = StateHeader(0);


    		StructInfoPayment.Entry_Mode = TRS_SCT; //KamalCless
    		StructInfoPayment.indexClessMag = 0;
    		Prepare_Transaction();

    		FicPara.AutoReversalOK =  4;

    		// Start the transaction
    		//ClessSample_ExplicitSelection_Process (FALSE,TRUE);//KamalCless
    		APCLESS_Explicit_DoTransaction();


    		FicPara.vCam0 = 3;
    		PutAllParam();
    		PutAllTra();
    		PutAllPre();

    		StateHeader(nOldStateHeader);
    		SendToApplication(0x57a9,1,2,"123456");
    	}
    }
    else if (pParamIn->type == 4) /* Msg from EMV Custom */
	{
        GTL_Traces_TraceDebug("msg type = 4 received");
#ifndef DISABLE_UNATTENDED
		ClessSample_Unattended_PrintDump((char*)pParamIn->value);
#endif
	}
	else if (pParamIn->type == COM_EVT_COMMUNICATION_ORDER) /* Msg from rs232 */
	{
#ifndef DISABLE_UNATTENDED
		ClessSample_Unattended_ExecuteCommand (pParamIn->length, (char*)pParamIn->value);
#endif
	}
	else if (pParamIn->type == COM_EVT_START_ORDER)
	{
		GTL_Traces_TraceDebug("COM_EVT_START_ORDER");
    	ClessSample_Comevent_Manage (DO_OPEN); /* return allways FCT_OK fct */
	}
	else if (pParamIn->type == COM_EVT_STOP_ORDER)
	{
		GTL_Traces_TraceDebug("COM_EVT_STOP_ORDER");
    	ClessSample_Comevent_Manage (DO_CLOSE); /* return allways FCT_OK fct */
	}
	
	if (hDisplay)
		Telium_Fclose(hDisplay);
	hDisplay = NULL;

	ClessSample_ComEventUnSetSerialRequest();
    
	return (FCT_OK);
}



/** 
 * \brief This service is called by the contactless kernels for customisation processing.
 * This is the application that provide kernel the service and the application type to call for customisation. 
 * \param[in] nSize Size of \a pData (not used as \a pData is a shared service call struct).
 * \param[in,out] pData Data structure containing the service data to be used.  
 * \return The service returned code.
 */
static int Main_(unsigned int nSize, StructPt* pData)
{
	NO_SEGMENT AppliNum;
	int nResult;

	(void)nSize;

	AppliNum = (NO_SEGMENT)ApplicationGetCurrent();
	switch(pData->service)
	{
	case AFTER_RESET:
		nResult = after_reset_(AppliNum, &pData->Param.AfterReset.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nafter_reset_", 1);
		break;
	case IS_DELETE:
		nResult = is_delete_(AppliNum, &pData->Param.IsDelete.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nIS_DELETE", 1);
		break;
	case IS_NAME:
		nResult = is_name_(AppliNum, &pData->Param.IsName.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nIS_NAME", 1);
		break;
	case IS_STATE:
		nResult = is_state_(AppliNum, &pData->Param.IsState.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nIS_STATE", 1);
		break;
	case FILE_RECEIVED:
		nResult = file_received_(AppliNum, &pData->Param.FileReceived.param_in);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nFILE_RECEIVED", 1);
		break;
	case GIVE_YOUR_DOMAIN:
		nResult = give_your_domain_(AppliNum, &pData->Param.GiveYourType.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nGIVE_YOUR_DOMAIN", 1);
		break;
	case GIVE_MONEY_EXTENDED:
		nResult = give_money_extended_(AppliNum, NULL, &pData->Param.GiveMoneyExtended.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nGIVE_MONEY_EXTENDED", 1);
		break;
	case MORE_FUNCTION:
		nResult = more_function_(AppliNum);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nMORE_FUNCTION", 1);
		break;
	case IS_CARD_SPECIFIC:
		nResult = is_card_specific_(AppliNum, &pData->Param.ClessIsSpecific.param_in, &pData->Param.ClessIsSpecific.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nIS_CARD_SPECIFIC", 1);
		break;
	case IS_CHANGE_INIT:
		nResult = is_change_init_(AppliNum, &pData->Param.IsChangeInit.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nCASA TRANSPORT", 1);
		break;
	case IS_EVOL_PG:
		nResult = is_evol_pg_ (AppliNum, &pData->Param.IsEvolPg.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nIS_CHANGE_INIT", 1);
		break;
	case IS_TIME_FUNCTION:
		nResult = is_time_function_(AppliNum, &pData->Param.IsTimeFunction.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nIS_TIME_FUNCTION", 1);
		break;
	case STATE:
		nResult = state_(AppliNum);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nSTATE", 1);
		break;
	case IDLE_MESSAGE:
		nResult = idle_message_(AppliNum);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nIDLE_MESSAGE", 1);
		break;
//	case CLESS_GIVE_INFO:
//		nResult = cless_give_info_ (AppliNum, &pData->Param.ClessGiveInfo.param_in, &pData->Param.ClessGiveInfo.param_out);
//		break;
//	case CLESS_DEBIT_AID:
//		nResult = cless_debit_aid_ (AppliNum, nSize, pData);
//		break;
//	case CLESS_END:
//		nResult = cless_end_ (AppliNum);
		break;
	case SELECT_FUNCTION_EMV:
		nResult = select_function_emv_(AppliNum,&pData->Param.SelectFunctionEmv.param_in,&pData->Param.SelectFunctionEmv.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nSELECT_FUNCTION_EMV", 1);
		break;
	case GIVE_YOUR_SPECIFIC_CONTEXT:
		nResult = give_your_specific_context_(AppliNum, &pData->Param.GiveYourSpecificContext.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nGIVE_YOUR_SPECIFIC_CONTEXT", 1);
		break;
	case KEYBOARD_EVENT:
		nResult = keyboard_event_(AppliNum, &pData->Param.KeyboardEvent.param_in, &pData->Param.KeyboardEvent.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nKEYBOARD_EVENT", 1);
		break;
	case COM_EVENT:
		nResult = ClessSample_Comevent_Event(AppliNum, &pData->Param.ComEvent.param_in, &pData->Param.ComEvent.param_out);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nCOM_EVENT", 1);
		break;
	case MESSAGE_RECEIVED:
		nResult = message_received_(AppliNum, &pData->Param.MessageReceived.param_in);
		//APEMV_UI_MessageDisplayDelay ("NAPS.CLESS\nMESSAGE_RECEIVED", 1);
		break;
	default:
		nResult = FCT_OK;
		break;
	}

	return nResult;
}



#ifdef __cplusplus
extern "C" {
#endif

/** entry() is called by the OS for recording services and opening DLL(s).                   
 *  The RegisteryPowerFailure() can also be moved to entry().
 * \header sdk30.h
 * \source entry.c 
*/
void entry(void)
{
	object_info_t info;
	
	/// Recording services
	ObjectGetInfo(OBJECT_TYPE_APPLI, ApplicationGetCurrent(),&info);
	give_interface_(info.application_type, NULL, NULL);
	
	//memcpy(appName,info.name,OBJECT_NAME_LEN);
	//appName[OBJECT_NAME_LEN] = '\0';
}

#ifdef __cplusplus
}
#endif
